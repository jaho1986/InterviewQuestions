Object oriented programming.
Is ma methodology or paradigm to design a program using Classes and Objects

Object 
Is a real world entity that has teir own properties an behaviours.

Class
Blueprint from wich objects properties a behaviours are decided.

Polymorphism:
Concept in wich a single action can be done in different ways.

Static Polymorphism:
Is the one that is resolved in compile time. Method overloading is an example of compile time polymorphism.

Dynamic Polymorphism:
Dynamic porlymorphism is a process in wich a call to an overridden methos is resolved at runtime. That's why it is called runtime polymorphism.

Advantages:
 - Support method overriding
 - Common method specification.

Example:
Cass A has a method move()
Cass B has a method move()
You create instances of the to classes and you call the method move of each class.

Characteristics of Polymorphism:
 - Operator overloading. (Operator + sum, or concatenate).
 - Polimorphic paarameters. (When you have local variables with the same name as the instance variables).
 
Super Keyword:
Super is a keyword. It is used inside a sub-class mehotd definition to call a  method in the superclass.

Why do we need inheritance?
 - To reduce code redundancy.
 - To improve the readability.
 
What is inheritance?
Is pa procedure, in wich a sub class inherits all the properties and behaviours of a super class.

Which types of inheritance ares supported in Java:
 - Single inheritance.
 - Multi-level inheritance.
 - Hierarchical inheritance.
 - Hybrid inheritance.
 
Single inheritance:
Is a process where a subclass inherits all properties and behaviour of a single super class.

Multi-level inheritance:
Is a process where a subclass inherits all the properties and behaviours of more than one super class at multiple levels.

Hierarchical inheritance:
Is a process where one or more subclasses inherits all the properties and beaviours of one super class.

Hybrid inheritance:
Is a combination of one or more inheritances.

Overloading:
Is a feature that allows a class to have more than one method having the same name, if their argument list are different.

Three types of method overloading:
 - Number of parameters.
 - Data types of the parameters.
 - Sequence of the data type of the parameters.

Overriding:
Is a feature that allows the parent class and the subclass to have a same method.

Rules of method overriding:
 - The argument list of the child should match the parent class.
 - Access modifier of the child class should be less restrictive than the parent class.
 - Local parameters cannot be overridden.
 
SOLID design principles:
Are the design principles that enable us manage most ot the software design problems. The termn SOLID is an acronym for five design principles intended to make software designs more understandable, fexible and maintainable.

 - S: Single responsablility principle.
 - O: Open closed principle.
 - L: Liskov substitution principle.
 - I: Interface segregation principle.
 - D: Dependency Inversion Principle.

Single responsablility principle:
Every module or class should have responsability over a single part of the functionality provided by the software, and that responsability should be entirely encapsulated by the class.

Open closed principle:
Software entities should be open for extension, but closed for modification.

Liskov substitution principle:
Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.

Interface segregation principle:
Many client-specific interfaces are better than one general-purpose interface. 
We should not enforce clients to implement interfaces that they don't use. Instead of creating a big interface we can break down it to smaller interfaces.

Dependency Inversion Principle:
One "should depend on abstractions, not concretions".
Abstractions should not depend on the details whereas the details should depend on abstractions.
High-level modules should not depend on low level modules.
It's used to create loosely coupled software modules. Modules should depend on abstraction by the use of interfaces instead of creating new objects inside a class.

Features of SOLID principles:
 - Achieve reduction in complexity of code.
 - Increases readability, extensibility and maintenance.
 - Reduce error and implement reusability.
 - Achieve better testability.
 - Reduce tight coupling.
 
Solution to develop a successful application:
 - Architecture: Choosing an architecture is the first step in designing application based on the requirements (MVC, WebAPI, etc).
 - Design principles.
 - Design patterns.
 
Generics in Java:
Is a term that denotes a set of language features relatet to the definition and use of Generic types and methods.

Types of generics:
 - Generic Type Class.
 - Generic Type Interface.
 - Generic Type Method.
 - Generic Type Constructor.
 
Generic functions:
We can also write generic functions that can be called with different types of arguments based of the type of aguments passed to the generic method and further the compiles handles this method.

Advantages of Generics in Java:
 - Code reusability.
 - Type safety.
 - Individual type casting not required.
 - Implementing non generic algorithms.
 
Collections in Java

Arraylist:
 - Is the implementation if List Interface.
 - Array is size fixed, but Arraylist size can grow dynamically.
 - ArrayList is used to store objects and perform operations on it.
 - ArrayList is not Syncronized. Vector is similar to ArrayList wich is synchronized.
 - If your applications does not require insertion or deletion of elements, the most efficient dasta structure is the array.
 
 How to create elements of arraylist?
  - For each loop.
  - Iterator.
  - List Iterator.
  - Enumeration.
  
 Vector:
 Vector is same as ArrayList. The only difference is that, Vector is syncronized but ArrayList is not. That means Vector is threadsafe.
 
 Queue:
  - Is an interface.
  - PriorityQueue is a class wich implements Queue iterface an sorts the data stored. DeQue satands for double ended queue.
  - The Queue can be operated at both ends. Same holds for insertion and deletion too.
  - Queue operates on the principle "First In First Out". 
 
 PriorityQueue:
 Is the one that sorts the data.
 
 Set:
  - Set is a collection interface. HashSet and TreeSet are implementations of set.
  - Set cannot have duplicates.
  - Class HashSet removes the duplicates and gives better performance over TreeSet. It doesn't guarantee to store the data in the same order it is inserted.
  - Class TreeSet sorts the added data apart from removing the duplicates.
  
 Comparable VS Comparator Java
  - Comparable is an interface used to compare objects by the comapreTo(Object o) method.
    Example: class nameClass implements Comparable<Object> {...
    ObjectClass > ObjectToCompare = +
    ObjectClass < ObjectToCompare = -
    ObjectClass = ObjectToCompare = 0
  - Comparator. We use comparator in 2 situations:
   - When the classes to compare don't implement the Comparable interface.
   - When you want to compare objects with a different logic that the one implemented with the comparable Interface.
     Example:
     Comparator<Object> comparator = new Comparator<Laptop>() {
       public int compare (Object o1, Object o2) {
         //logic here...
       }
     };

Thread:
 - Thread is a lightweight sub process.
 - It is the smallest independent unit of a program.
 - Contains a separate path of execution.
 - Every Java program contains at least one thread.
 - A thread is created and controlled by the java.lang.Thread class

Thread Lifecycle:
 - New
 - Runnable \
 -           Waiting
 - Running  /
 - Terminated
 
New:
When you create a thread it begins with the state of 'new' until the program starts the thread.

Runnable:
Once the thread starts, it comes under runnable state and it stays in this state while is executing its task.

Running:
In this state a thread starts executing by entering the run() method. yield() method can send it to go back to the runnable state.

Waiting:
A thread enters this state when it is temporarilly in an incactive state. It's still alive, but is not elegible to run.

Terminated:
A thread enters in terminated state when it completes its tasks.

Ways to create a thread:
 - Implementing the Runnable Interface.
   1. Create a Thread class implementing the Runnable Interface.
   2. Override the run() method.
   3. Create object of the Thread class.
   4. Invoke the start() method using the object.
   
 - Extending from the Thread Class.
   1. Exends the Thread Class.
   2. Override run() method.
   3. Create object of the class.
   4. Invoke the start() method, to execute the custom threads run().
 
Thread Class:
 - Each thread creates its unique object.
 - More memory consumption.
 - A class that extends the Thread class can't extend any other class.
 - We extend the Thread class if there is a need of overriding other methods.

Runnable Interface:
 - Each Thread creates its unique object.
 - More memory consumption.
 - Along with runnable a class can implement ano other interface.
 - We implement Runnable only if there is a need of special run method.
 
Java Main Thread:
 - Main Thread is the most important thread of a Java Program.
 - It is excecuted whenever a Java program Starts.
 - Every program must contain this thread for its execution to take place.
 - Java Main Thread is needed because of the following reasons:
   - From this other "child" threads are spawned.
   - It must be the las thread to finish execution Eg. When the main thread stops, the program terminates.
   
Multi Threading:
Multi Threading is the ability of a program to run two or more threads concurrently, where each thread can handle a different task at the same time making optimal use of the available resources.

Synchronized methods are used to guarantee that a method can only be accessed by one thread at a time. 
We use sincronized when multiples threads work on the same object.

Thread Pool:
Java Thread Pool manages the pool of worker threads and contains a queue that keep the tasks waiting to be executed.

LinkedList:
A linked list is a linear data structure wich is constituted by a chain of nodes in wich each node contains a value an a pointer to the next node in the chain.

 - Implements Queue and Deque interfaces.
 - Contain insertion Order.
 - It's not synchronized.

ArrayList:
Arraylist is the implementation of the List interface where the elements can be dynamically added or removed from the list. We use arraylist when we want to have a dynamic collection of elements.

Similairities between LinkkedList and ArrayList:
 - They are implementations of the List interface.
 - They maintain the insertion order of the elements.
 - Their classes are not synchronized.

LinkedList VS ArrayList:
 - Insertion, deletion, and removal are faster in LinedList because thre is no need for resize like in an Arraylist.
 - LinkedList is based on doubly linked listjimplementation whereas Arraylist is based on the concept of a dynamically resizable array.
 - A LinkedList class can me used as a list and a queue because it implements List and Deque interfaces whereas Arraylist can only implement Lists.
 - LinkedList consumes mora memory than an ArrayList because every node in a LinkedList stores two references, whereas ArrayList holds only data and its index.
 

HashTable:
 - It's an implementation of the Map Interface.
 - All methods are thread-safe.
 - There is a "synchronized" keyword on each public method (put, get, remove, etc).
 - Overhead in an environment where Map is initialized once and read by multiple threads.

HashMap:
 - Map implementation that satisfies most of the basic use cases.
 - Not "thread-safe".
 - Itaration not guaranteed in insertion order.
 - We need to use the "synchronized" operation when is manipulated by multiple threads (concurrent adds, removes, iterations).
 - Most of the enterprise applications populate the map once and then read it many times from many threads. Given this Hashmap suffices for all such scenarios, without any worries of performace overheads.

LinkedHashMap:
 - It's very similar to HashMap.
 - Iteration is guaranteed in insertion order.
 - Maintains separate doubly linked list of all entries that is kept in insertion order.
 - It can be used in cases where hash map behavior is needed at the same time that the order of the insertion has to be preserved.

TreeMap:
 - Implementation of SortedMap and NavigableMap interfaces.
 - Iteration is guranteed in"natural sorted" order of keys.
 - The keys should implement "Comparable Interface" (ClassCastException is thrown if it's not implemented); in other case, we need to provide an explicit Comparator in the constructor.
 - It's a Red-black tree based implementation. NavigableMap interface provides methods that can return closes match to the key (floorEntry()).

IdentityHashMap:
 - Uses identity to store and retrieve key values.
 - It uses reference equality; meaning r1==r2 rather than r1.equals(r2). For hashing, System.identityHashCode(givenKey) is invoked rather than givenKey.hashCode().
 - It's used in serialization/deep copying
